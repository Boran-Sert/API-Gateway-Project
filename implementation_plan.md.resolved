# Mikroservis Mimarisi ve API Gateway â€” UÃ§tan Uca TasarÄ±m

## Genel BakÄ±ÅŸ

BiliÅŸim Sistemleri MÃ¼hendisliÄŸi bitirme projesi iÃ§in endÃ¼stri standartlarÄ±nda bir **Mikroservis Mimarisi** tasarÄ±mÄ±. Tek giriÅŸ noktasÄ± olan bir **API Gateway (Dispatcher)**, merkezi Redis tabanlÄ± yetkilendirme, servis baÅŸÄ±na baÄŸÄ±msÄ±z MongoDB veritabanlarÄ±, Docker aÄŸ izolasyonu, TDD geliÅŸtirme disiplini, HATEOAS uyumlu REST API'ler ve Grafana ile izleme altyapÄ±sÄ±nÄ± kapsar.

**Teknoloji YÄ±ÄŸÄ±nÄ±:** Python 3.11+ Â· FastAPI Â· Pytest Â· Redis Â· MongoDB Â· Docker Â· Locust Â· Prometheus Â· Grafana

---

## 1. Sistem Mimarisi DiyagramÄ±

```mermaid
graph TB
    subgraph EXTERNAL["ğŸŒ DÄ±ÅŸ AÄŸ â€” public_network"]
        CLIENT["ğŸ§‘â€ğŸ’» Ä°stemci<br/>(Browser / Postman / Locust)"]
    end

    subgraph GATEWAY_NET["ğŸ›¡ï¸ Gateway AÄŸÄ± â€” gateway_network"]
        DISPATCHER["âš¡ Dispatcher<br/>(API Gateway)<br/>:8000"]
        REDIS["ğŸ”´ Redis<br/>(Auth Token Store)<br/>:6379"]
        PROMETHEUS["ğŸ“Š Prometheus<br/>:9090"]
        GRAFANA["ğŸ“ˆ Grafana<br/>:3000"]
    end

    subgraph INTERNAL_NET["ğŸ”’ Ä°Ã§ AÄŸ â€” internal_network"]
        AUTH["ğŸ” Auth Service<br/>:8001"]
        USER_SVC["ğŸ‘¤ User Service<br/>:8002"]
        PRODUCT_SVC["ğŸ“¦ Product Service<br/>:8003"]
        MONGO_AUTH["ğŸƒ MongoDB<br/>(auth_db)"]
        MONGO_USER["ğŸƒ MongoDB<br/>(user_db)"]
        MONGO_PRODUCT["ğŸƒ MongoDB<br/>(product_db)"]
    end

    CLIENT -->|"HTTP/HTTPS"| DISPATCHER
    DISPATCHER -->|"Token DoÄŸrulama"| REDIS
    DISPATCHER -->|"Proxy"| AUTH
    DISPATCHER -->|"Proxy"| USER_SVC
    DISPATCHER -->|"Proxy"| PRODUCT_SVC
    AUTH --> MONGO_AUTH
    AUTH -->|"Token OluÅŸtur/Sil"| REDIS
    USER_SVC --> MONGO_USER
    PRODUCT_SVC --> MONGO_PRODUCT
    PROMETHEUS -->|"Scrape /metrics"| DISPATCHER
    PROMETHEUS -->|"Scrape /metrics"| AUTH
    PROMETHEUS -->|"Scrape /metrics"| USER_SVC
    PROMETHEUS -->|"Scrape /metrics"| PRODUCT_SVC
    GRAFANA -->|"Query"| PROMETHEUS

    style EXTERNAL fill:#1a1a2e,stroke:#e94560,color:#fff
    style GATEWAY_NET fill:#16213e,stroke:#0f3460,color:#fff
    style INTERNAL_NET fill:#0f3460,stroke:#533483,color:#fff
    style DISPATCHER fill:#e94560,stroke:#fff,color:#fff
    style REDIS fill:#d63031,stroke:#fff,color:#fff
    style AUTH fill:#00b894,stroke:#fff,color:#fff
    style USER_SVC fill:#0984e3,stroke:#fff,color:#fff
    style PRODUCT_SVC fill:#6c5ce7,stroke:#fff,color:#fff
```

### Ä°stek AkÄ±ÅŸ DiyagramÄ±

```mermaid
sequenceDiagram
    participant C as ğŸ§‘â€ğŸ’» Ä°stemci
    participant D as âš¡ Dispatcher
    participant R as ğŸ”´ Redis
    participant A as ğŸ” Auth Service
    participant U as ğŸ‘¤ User Service

    Note over C,U: 1. Oturum AÃ§ma (Login) AkÄ±ÅŸÄ±
    C->>D: POST /api/v1/auth/login {email, password}
    D->>A: POST /login (iÃ§ aÄŸ)
    A->>A: Kimlik bilgisi doÄŸrulama
    A->>R: SET token â†’ user_id (TTL: 3600s)
    A-->>D: 200 {token, _links}
    D-->>C: 200 {token, _links}

    Note over C,U: 2. KorumalÄ± Kaynak EriÅŸimi
    C->>D: GET /api/v1/users/me [Authorization: Bearer <token>]
    D->>R: GET token â†’ user_id
    R-->>D: user_id (geÃ§erli)
    D->>U: GET /users/me [X-User-Id: user_id] (iÃ§ aÄŸ)
    U-->>D: 200 {user, _links}
    D-->>C: 200 {user, _links}

    Note over C,U: 3. GeÃ§ersiz Token Senaryosu
    C->>D: GET /api/v1/users/me [Authorization: Bearer <expired>]
    D->>R: GET token
    R-->>D: null
    D-->>C: 401 {detail: "Unauthorized", _links: {login: ...}}
```

---

## 2. Docker AÄŸ Ä°zolasyonu TasarÄ±mÄ±

> [!IMPORTANT]
> Mikroservisler dÄ±ÅŸarÄ±dan **asla eriÅŸilemez**. YalnÄ±zca Dispatcher dÄ±ÅŸ dÃ¼nyaya port aÃ§ar.

### AÄŸ Topolojisi

| AÄŸ AdÄ± | Tip | BaÄŸlÄ± Konteynerler | DÄ±ÅŸ Port |
|---|---|---|---|
| `public_network` | bridge | Dispatcher, Grafana, Prometheus | 8000, 3000, 9090 |
| `gateway_network` | bridge | Dispatcher, Redis | â€” |
| `internal_network` | internal | Dispatcher, Auth, User, Product, MongoDB'ler | â€” |

```yaml
# docker-compose.yml â€” AÄŸ TanÄ±mlarÄ±
networks:
  public_network:
    driver: bridge
  gateway_network:
    driver: bridge
  internal_network:
    driver: bridge
    internal: true  # â† DÄ±ÅŸarÄ±dan eriÅŸimi tamamen engeller
```

### Servis-AÄŸ EÅŸlemesi

```yaml
services:
  dispatcher:
    ports:
      - "8000:8000"          # Tek dÄ±ÅŸ eriÅŸim noktasÄ±
    networks:
      - public_network
      - gateway_network
      - internal_network

  redis:
    networks:
      - gateway_network      # YalnÄ±zca Dispatcher eriÅŸir
    # ports YOK â†’ dÄ±ÅŸarÄ±ya kapalÄ±

  auth-service:
    networks:
      - internal_network     # YalnÄ±zca iÃ§ aÄŸda
    # ports YOK â†’ dÄ±ÅŸarÄ±ya kapalÄ±

  user-service:
    networks:
      - internal_network
  
  product-service:
    networks:
      - internal_network

  mongo-auth:
    networks:
      - internal_network

  mongo-user:
    networks:
      - internal_network

  mongo-product:
    networks:
      - internal_network
```

> [!TIP]
> `internal: true` flag'i, Docker'Ä±n bu aÄŸdaki konteynerler iÃ§in **dÄ±ÅŸ dÃ¼nyaya NAT/routing kuralÄ± oluÅŸturmamasÄ±nÄ±** saÄŸlar. Bu sayede `auth-service`, `user-service`, `product-service` ve MongoDB'ler yalnÄ±zca `internal_network` Ã¼zerinden birbirleriyle ve Dispatcher ile iletiÅŸim kurabilir.

---

## 3. Proje Dosya YapÄ±sÄ±

```
microservice-graduation-project/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ docker-compose.monitoring.yml
â”œâ”€â”€ .env.example
â”œâ”€â”€ README.md
â”‚
â”œâ”€â”€ dispatcher/                      # API Gateway
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ main.py                  # FastAPI uygulamasÄ±
â”‚   â”‚   â”œâ”€â”€ config.py                # Ortam deÄŸiÅŸkenleri
â”‚   â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ auth_middleware.py   # Redis token doÄŸrulama
â”‚   â”‚   â”‚   â””â”€â”€ rate_limiter.py
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ proxy.py             # Servis yÃ¶nlendirme
â”‚   â”‚   â”‚   â””â”€â”€ health.py
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ service_registry.py  # Servis keÅŸfi
â”‚   â”‚   â””â”€â”€ core/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ exceptions.py        # Merkezi hata yÃ¶netimi
â”‚   â”‚       â””â”€â”€ hateoas.py           # HATEOAS link builder
â”‚   â””â”€â”€ tests/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ conftest.py              # Shared fixtures
â”‚       â”œâ”€â”€ test_auth_middleware.py
â”‚       â”œâ”€â”€ test_proxy.py
â”‚       â”œâ”€â”€ test_rate_limiter.py
â”‚       â””â”€â”€ test_hateoas.py
â”‚
â”œâ”€â”€ auth-service/                    # Oturum AÃ§ma Servisi
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ auth_controller.py
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ auth_service.py
â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py              # Abstract Repository
â”‚   â”‚   â”‚   â””â”€â”€ user_credential_repo.py
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ domain.py            # Pydantic domain modelleri
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py           # Request/Response ÅŸemalarÄ±
â”‚   â”‚   â””â”€â”€ core/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ exceptions.py
â”‚   â”‚       â”œâ”€â”€ hateoas.py
â”‚   â”‚       â””â”€â”€ security.py          # Password hashing
â”‚   â””â”€â”€ tests/
â”‚       â”œâ”€â”€ conftest.py
â”‚       â”œâ”€â”€ unit/
â”‚       â”‚   â”œâ”€â”€ test_auth_service.py
â”‚       â”‚   â””â”€â”€ test_security.py
â”‚       â””â”€â”€ integration/
â”‚           â””â”€â”€ test_auth_api.py
â”‚
â”œâ”€â”€ user-service/                    # KullanÄ±cÄ± Servisi
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â””â”€â”€ user_controller.py
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ user_service.py
â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â”‚   â””â”€â”€ user_repo.py
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ domain.py
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py
â”‚   â”‚   â””â”€â”€ core/
â”‚   â”‚       â”œâ”€â”€ exceptions.py
â”‚   â”‚       â””â”€â”€ hateoas.py
â”‚   â””â”€â”€ tests/
â”‚       â”œâ”€â”€ conftest.py
â”‚       â”œâ”€â”€ unit/
â”‚       â”‚   â””â”€â”€ test_user_service.py
â”‚       â””â”€â”€ integration/
â”‚           â””â”€â”€ test_user_api.py
â”‚
â”œâ”€â”€ product-service/                 # ÃœrÃ¼n Servisi
â”‚   â”œâ”€â”€ (user-service ile aynÄ± yapÄ±)
â”‚
â”œâ”€â”€ shared/                          # PaylaÅŸÄ±lan kÃ¼tÃ¼phane
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_repository.py           # Abstract base class
â”‚   â”œâ”€â”€ base_service.py
â”‚   â”œâ”€â”€ hateoas.py                   # HATEOAS utilities
â”‚   â”œâ”€â”€ exceptions.py                # Ortak hata sÄ±nÄ±flarÄ±
â”‚   â””â”€â”€ middleware.py                # Ortak middleware'ler
â”‚
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ prometheus/
â”‚   â”‚   â””â”€â”€ prometheus.yml
â”‚   â””â”€â”€ grafana/
â”‚       â””â”€â”€ dashboards/
â”‚           â””â”€â”€ dispatcher-dashboard.json
â”‚
â””â”€â”€ load-tests/
    â”œâ”€â”€ locustfile.py
    â””â”€â”€ k6/
        â””â”€â”€ load_test.js
```

---

## 4. TDD Stratejisi ve Commit Disiplini

### 4.1 Red-Green-Refactor DÃ¶ngÃ¼sÃ¼

```mermaid
graph LR
    RED["ğŸ”´ RED<br/>BaÅŸarÄ±sÄ±z test yaz"]
    GREEN["ğŸŸ¢ GREEN<br/>Testi geÃ§ecek<br/>minimum kodu yaz"]
    REFACTOR["ğŸ”µ REFACTOR<br/>Kodu iyileÅŸtir,<br/>testler hÃ¢lÃ¢ geÃ§meli"]
    
    RED --> GREEN --> REFACTOR --> RED

    style RED fill:#e74c3c,stroke:#c0392b,color:#fff
    style GREEN fill:#27ae60,stroke:#219a52,color:#fff
    style REFACTOR fill:#2980b9,stroke:#2471a3,color:#fff
```

### 4.2 Git Commit Stratejisi (Zaman DamgasÄ± KanÄ±tÄ±)

TDD'nin kanÄ±tlanmasÄ± iÃ§in test dosyasÄ±nÄ±n **her zaman** uygulama kodundan Ã¶nce commit edilmesi gerekir:

```bash
# AdÄ±m 1: Ã–nce baÅŸarÄ±sÄ±z testi yaz ve commit et
git add auth-service/tests/unit/test_auth_service.py
git commit -m "test(auth): add failing test for login with invalid credentials

- RED phase: test_login_invalid_credentials expects 401 response
- Test written BEFORE implementation"

# AdÄ±m 2: Testi geÃ§irecek kodu yaz ve commit et
git add auth-service/app/services/auth_service.py
git commit -m "feat(auth): implement login validation logic

- GREEN phase: minimum code to pass test_login_invalid_credentials
- Validates email/password against MongoDB credentials"

# AdÄ±m 3: Refactor ve commit et
git add auth-service/app/services/auth_service.py
git commit -m "refactor(auth): extract password hashing to security module

- REFACTOR phase: all tests still passing
- Moved bcrypt logic to core/security.py for reusability"
```

### 4.3 Pytest YapÄ±landÄ±rmasÄ±

```ini
# pytest.ini (her servis kÃ¶k dizininde)
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
markers =
    unit: Unit testler (mock kullanÄ±r)
    integration: Entegrasyon testleri (gerÃ§ek DB gerektirir)
    e2e: UÃ§tan uca testler
addopts = -v --tb=short --strict-markers --cov=app --cov-report=term-missing
```

```python
# tests/conftest.py â€” PaylaÅŸÄ±lan Fixture'lar
import pytest
from unittest.mock import AsyncMock, MagicMock
from httpx import AsyncClient, ASGITransport
from app.main import app


@pytest.fixture
def mock_mongo_collection():
    """MongoDB collection mock'u â€” unit testler iÃ§in."""
    collection = MagicMock()
    collection.find_one = AsyncMock()
    collection.insert_one = AsyncMock()
    collection.update_one = AsyncMock()
    collection.delete_one = AsyncMock()
    return collection


@pytest.fixture
async def async_client():
    """FastAPI test istemcisi â€” integration testler iÃ§in."""
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client


@pytest.fixture
def sample_user():
    """Test kullanÄ±cÄ± verisi."""
    return {
        "email": "test@example.com",
        "password": "SecurePass123!",
        "full_name": "Test KullanÄ±cÄ±",
    }
```

---

## 5. Hata YÃ¶netimi â€” Sahte 200 YasaÄŸÄ±

> [!CAUTION]
> API asla baÅŸarÄ±sÄ±z bir iÅŸlem iÃ§in `HTTP 200` dÃ¶nmemelidir. Her hata durumu uygun HTTP durum koduyla temsil edilmelidir.

### Merkezi Hata YapÄ±sÄ±

```python
# shared/exceptions.py
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse


class AppException(Exception):
    """TÃ¼m uygulama hatalarÄ±nÄ±n temel sÄ±nÄ±fÄ±."""
    def __init__(self, status_code: int, detail: str, error_code: str):
        self.status_code = status_code
        self.detail = detail
        self.error_code = error_code


class NotFoundException(AppException):
    def __init__(self, resource: str, resource_id: str):
        super().__init__(
            status_code=404,
            detail=f"{resource} bulunamadÄ±: {resource_id}",
            error_code="RESOURCE_NOT_FOUND",
        )


class UnauthorizedException(AppException):
    def __init__(self, detail: str = "GeÃ§ersiz veya sÃ¼resi dolmuÅŸ token"):
        super().__init__(
            status_code=401,
            detail=detail,
            error_code="UNAUTHORIZED",
        )


class ConflictException(AppException):
    def __init__(self, detail: str):
        super().__init__(
            status_code=409,
            detail=detail,
            error_code="CONFLICT",
        )


# FastAPI exception handler olarak kayÄ±t
async def app_exception_handler(request: Request, exc: AppException) -> JSONResponse:
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "success": False,
            "error": {
                "code": exc.error_code,
                "detail": exc.detail,
            },
            "_links": {
                "self": {"href": str(request.url), "method": request.method},
                "docs": {"href": "/docs"},
            },
        },
    )
```

### HTTP Durum Kodu HaritasÄ±

| Durum | Kod | KullanÄ±m |
|---|---|---|
| BaÅŸarÄ±lÄ± oluÅŸturma | `201 Created` | KayÄ±t, token oluÅŸturma |
| Kaynak yok | `204 No Content` | Silme baÅŸarÄ±lÄ± |
| GeÃ§ersiz istek | `400 Bad Request` | Validasyon hatalarÄ± |
| Yetkisiz | `401 Unauthorized` | Token eksik/geÃ§ersiz |
| Yasak | `403 Forbidden` | Yetersiz yetki seviyesi |
| BulunamadÄ± | `404 Not Found` | Kaynak mevcut deÄŸil |
| Ã‡akÄ±ÅŸma | `409 Conflict` | Duplicate email vb. |
| Sunucu hatasÄ± | `500 Internal Server Error` | Beklenmeyen hatalar |
| Servis kapalÄ± | `503 Service Unavailable` | Downstream servis eriÅŸilemez |

---

## 6. RMM Seviye 3 â€” HATEOAS UygulamasÄ±

### 6.1 HATEOAS Link Builder

```python
# shared/hateoas.py
from typing import Any


class HateoasLink:
    """Tek bir HATEOAS linkini temsil eder."""
    def __init__(self, href: str, method: str = "GET", rel: str | None = None):
        self.href = href
        self.method = method
        self.rel = rel

    def to_dict(self) -> dict[str, str]:
        result = {"href": self.href, "method": self.method}
        if self.rel:
            result["rel"] = self.rel
        return result


class HateoasBuilder:
    """HATEOAS uyumlu response oluÅŸturur."""
    
    def __init__(self, base_url: str = "/api/v1"):
        self.base_url = base_url

    def build_response(
        self, data: dict[str, Any], links: dict[str, HateoasLink]
    ) -> dict[str, Any]:
        return {
            **data,
            "_links": {name: link.to_dict() for name, link in links.items()},
        }

    def collection_response(
        self,
        items: list[dict],
        resource_name: str,
        page: int = 1,
        per_page: int = 20,
        total: int = 0,
    ) -> dict[str, Any]:
        total_pages = (total + per_page - 1) // per_page
        base = f"{self.base_url}/{resource_name}"

        links: dict[str, HateoasLink] = {
            "self": HateoasLink(href=f"{base}?page={page}&per_page={per_page}"),
            "create": HateoasLink(href=base, method="POST"),
        }

        if page > 1:
            links["prev"] = HateoasLink(
                href=f"{base}?page={page - 1}&per_page={per_page}"
            )
        if page < total_pages:
            links["next"] = HateoasLink(
                href=f"{base}?page={page + 1}&per_page={per_page}"
            )

        return {
            "data": items,
            "meta": {"page": page, "per_page": per_page, "total": total},
            "_links": {k: v.to_dict() for k, v in links.items()},
        }
```

### 6.2 Ã–rnek HATEOAS YanÄ±tlarÄ±

**Tek Kaynak â€” `GET /api/v1/users/6789`**
```json
{
  "data": {
    "id": "6789",
    "email": "boran@example.com",
    "full_name": "Boran YÄ±lmaz",
    "created_at": "2026-02-25T10:00:00Z"
  },
  "_links": {
    "self":     { "href": "/api/v1/users/6789", "method": "GET" },
    "update":   { "href": "/api/v1/users/6789", "method": "PUT" },
    "delete":   { "href": "/api/v1/users/6789", "method": "DELETE" },
    "products": { "href": "/api/v1/users/6789/products", "method": "GET" },
    "collection": { "href": "/api/v1/users", "method": "GET" }
  }
}
```

**Koleksiyon â€” `GET /api/v1/products?page=2&per_page=10`**
```json
{
  "data": [
    {
      "id": "p101",
      "name": "Laptop",
      "price": 29999.99,
      "_links": {
        "self":   { "href": "/api/v1/products/p101", "method": "GET" },
        "update": { "href": "/api/v1/products/p101", "method": "PUT" },
        "owner":  { "href": "/api/v1/users/6789", "method": "GET" }
      }
    }
  ],
  "meta": { "page": 2, "per_page": 10, "total": 45 },
  "_links": {
    "self":   { "href": "/api/v1/products?page=2&per_page=10", "method": "GET" },
    "prev":   { "href": "/api/v1/products?page=1&per_page=10", "method": "GET" },
    "next":   { "href": "/api/v1/products?page=3&per_page=10", "method": "GET" },
    "create": { "href": "/api/v1/products", "method": "POST" }
  }
}
```

**Hata YanÄ±tÄ± â€” `GET /api/v1/users/9999`**
```json
{
  "success": false,
  "error": {
    "code": "RESOURCE_NOT_FOUND",
    "detail": "User bulunamadÄ±: 9999"
  },
  "_links": {
    "self":  { "href": "/api/v1/users/9999", "method": "GET" },
    "collection": { "href": "/api/v1/users", "method": "GET" },
    "docs":  { "href": "/docs" }
  }
}
```

---

## 7. OOP / SOLID Prensipleri ve KatmanlaÅŸma

### 7.1 Mimari Katmanlar

```mermaid
graph TD
    subgraph PRESENTATION["ğŸ“¡ Sunum KatmanÄ± (Controller)"]
        CTRL["UserController<br/>FastAPI Router"]
    end
    subgraph BUSINESS["âš™ï¸ Ä°ÅŸ MantÄ±ÄŸÄ± KatmanÄ± (Service)"]
        SVC["UserService<br/>Ä°ÅŸ KurallarÄ±"]
    end
    subgraph DATA["ğŸ’¾ Veri EriÅŸim KatmanÄ± (Repository)"]
        REPO["UserRepository<br/>MongoDB CRUD"]
    end
    subgraph DOMAIN["ğŸ“¦ Domain KatmanÄ± (Models)"]
        MODEL["User<br/>Pydantic Model"]
    end

    CTRL -->|"DTO/Schema"| SVC
    SVC -->|"Domain Model"| REPO
    REPO -->|"Document"| MODEL

    style PRESENTATION fill:#e94560,stroke:#fff,color:#fff
    style BUSINESS fill:#0984e3,stroke:#fff,color:#fff
    style DATA fill:#00b894,stroke:#fff,color:#fff
    style DOMAIN fill:#6c5ce7,stroke:#fff,color:#fff
```

### 7.2 SOLID Implementation

```python
# â”€â”€â”€ S: Single Responsibility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Her sÄ±nÄ±f tek bir sorumluluÄŸa sahip

# â”€â”€â”€ O: Open/Closed â”€â”€ I: Interface Segregation â”€â”€â”€â”€â”€â”€â”€â”€
# â”€â”€â”€ D: Dependency Inversion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

from abc import ABC, abstractmethod
from typing import TypeVar, Generic
from pydantic import BaseModel

T = TypeVar("T", bound=BaseModel)


# â”€â”€ Abstract Repository (Dependency Inversion + Open/Closed) â”€â”€
class AbstractRepository(ABC, Generic[T]):
    """Soyut Repository â€” tÃ¼m veri eriÅŸim sÄ±nÄ±flarÄ±nÄ±n arayÃ¼zÃ¼.
    
    SOLID:
      - D (Dependency Inversion): Service katmanÄ± bu arayÃ¼ze baÄŸÄ±mlÄ±dÄ±r,
        somut MongoDB implementasyonuna deÄŸil.
      - O (Open/Closed): Yeni bir DB (PostgreSQL vb.) eklemek iÃ§in
        mevcut kodu deÄŸiÅŸtirmeden yeni bir sÄ±nÄ±f tÃ¼retmek yeterli.
      - I (Interface Segregation): YalnÄ±zca CRUD operasyonlarÄ± tanÄ±mlÄ±.
    """

    @abstractmethod
    async def find_by_id(self, id: str) -> T | None: ...

    @abstractmethod
    async def find_all(self, skip: int = 0, limit: int = 20) -> list[T]: ...

    @abstractmethod
    async def create(self, entity: T) -> T: ...

    @abstractmethod
    async def update(self, id: str, entity: T) -> T | None: ...

    @abstractmethod
    async def delete(self, id: str) -> bool: ...


# â”€â”€ Abstract Service â”€â”€
class AbstractService(ABC, Generic[T]):
    """Soyut Service â€” iÅŸ mantÄ±ÄŸÄ± katmanÄ± arayÃ¼zÃ¼."""

    def __init__(self, repository: AbstractRepository[T]):
        self._repository = repository  # Dependency Injection

    @abstractmethod
    async def get_by_id(self, id: str) -> T: ...

    @abstractmethod
    async def get_all(self, page: int, per_page: int) -> tuple[list[T], int]: ...


# â”€â”€ Concrete MongoDB Repository â”€â”€
from motor.motor_asyncio import AsyncIOMotorCollection


class MongoRepository(AbstractRepository[T]):
    """MongoDB implementasyonu.
    
    SOLID:
      - L (Liskov Substitution): AbstractRepository yerine kullanÄ±labilir.
      - S (Single Responsibility): YalnÄ±zca MongoDB CRUD sorumlu.
    """

    def __init__(self, collection: AsyncIOMotorCollection, model_class: type[T]):
        self._collection = collection
        self._model_class = model_class

    async def find_by_id(self, id: str) -> T | None:
        doc = await self._collection.find_one({"_id": id})
        return self._model_class(**doc) if doc else None

    async def find_all(self, skip: int = 0, limit: int = 20) -> list[T]:
        cursor = self._collection.find().skip(skip).limit(limit)
        return [self._model_class(**doc) async for doc in cursor]

    async def create(self, entity: T) -> T:
        doc = entity.model_dump(by_alias=True)
        await self._collection.insert_one(doc)
        return entity

    async def update(self, id: str, entity: T) -> T | None:
        result = await self._collection.update_one(
            {"_id": id}, {"$set": entity.model_dump(exclude={"id"}, by_alias=True)}
        )
        return entity if result.modified_count else None

    async def delete(self, id: str) -> bool:
        result = await self._collection.delete_one({"_id": id})
        return result.deleted_count > 0


# â”€â”€ Concrete User Service â”€â”€
from shared.exceptions import NotFoundException


class UserService(AbstractService["User"]):
    """KullanÄ±cÄ± iÅŸ mantÄ±ÄŸÄ±.
    
    SOLID:
      - S: YalnÄ±zca kullanÄ±cÄ± iÅŸ kurallarÄ±.
      - D: AbstractRepository'ye baÄŸÄ±mlÄ±, MongoDB'ye deÄŸil.
    """

    async def get_by_id(self, id: str) -> "User":
        user = await self._repository.find_by_id(id)
        if not user:
            raise NotFoundException("User", id)
        return user

    async def get_all(self, page: int = 1, per_page: int = 20) -> tuple[list["User"], int]:
        skip = (page - 1) * per_page
        users = await self._repository.find_all(skip=skip, limit=per_page)
        # Total count for pagination
        total = await self._repository._collection.count_documents({})
        return users, total


# â”€â”€ Controller (FastAPI Router) â”€â”€
from fastapi import APIRouter, Depends

router = APIRouter(prefix="/users", tags=["Users"])


@router.get("/{user_id}")
async def get_user(user_id: str, service: UserService = Depends(get_user_service)):
    user = await service.get_by_id(user_id)
    return HateoasBuilder("/api/v1").build_response(
        data=user.model_dump(),
        links={
            "self":   HateoasLink(href=f"/api/v1/users/{user_id}"),
            "update": HateoasLink(href=f"/api/v1/users/{user_id}", method="PUT"),
            "delete": HateoasLink(href=f"/api/v1/users/{user_id}", method="DELETE"),
        },
    )
```

---

## 8. Dispatcher (API Gateway) DetaylÄ± TasarÄ±mÄ±

### 8.1 Redis TabanlÄ± Merkezi Auth Middleware

```python
# dispatcher/app/middleware/auth_middleware.py
import redis.asyncio as redis
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse

# Public rotalar â€” auth gerektirmeyen
PUBLIC_PATHS = {
    "/api/v1/auth/login",
    "/api/v1/auth/register",
    "/health",
    "/docs",
    "/openapi.json",
    "/metrics",
}


class AuthMiddleware(BaseHTTPMiddleware):
    """Redis tabanlÄ± merkezi yetkilendirme middleware'i."""

    def __init__(self, app, redis_client: redis.Redis):
        super().__init__(app)
        self.redis = redis_client

    async def dispatch(self, request: Request, call_next):
        # Public path kontrolÃ¼
        if request.url.path in PUBLIC_PATHS:
            return await call_next(request)

        # Token Ã§Ä±karma
        auth_header = request.headers.get("Authorization", "")
        if not auth_header.startswith("Bearer "):
            return JSONResponse(
                status_code=401,
                content={
                    "success": False,
                    "error": {"code": "MISSING_TOKEN", "detail": "Authorization header gerekli"},
                    "_links": {"login": {"href": "/api/v1/auth/login", "method": "POST"}},
                },
            )

        token = auth_header.removeprefix("Bearer ").strip()

        # Redis'ten token doÄŸrulama
        user_id = await self.redis.get(f"session:{token}")
        if not user_id:
            return JSONResponse(
                status_code=401,
                content={
                    "success": False,
                    "error": {"code": "INVALID_TOKEN", "detail": "GeÃ§ersiz veya sÃ¼resi dolmuÅŸ token"},
                    "_links": {"login": {"href": "/api/v1/auth/login", "method": "POST"}},
                },
            )

        # User ID'yi downstream servislere ilet
        request.state.user_id = user_id.decode()
        return await call_next(request)
```

### 8.2 Servis Proxy / YÃ¶nlendirme

```python
# dispatcher/app/routes/proxy.py
import httpx
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from app.services.service_registry import ServiceRegistry

router = APIRouter()
registry = ServiceRegistry()


@router.api_route(
    "/api/v1/{service_name}/{path:path}",
    methods=["GET", "POST", "PUT", "PATCH", "DELETE"],
)
async def proxy_request(service_name: str, path: str, request: Request):
    """Gelen istekleri uygun mikroservise yÃ¶nlendirir."""
    
    target_url = registry.resolve(service_name, path)
    if not target_url:
        return JSONResponse(
            status_code=404,
            content={
                "success": False,
                "error": {"code": "SERVICE_NOT_FOUND", "detail": f"Servis bulunamadÄ±: {service_name}"},
                "_links": {"docs": {"href": "/docs"}},
            },
        )

    headers = dict(request.headers)
    # Ä°Ã§ aÄŸ header'larÄ± ekle
    if hasattr(request.state, "user_id"):
        headers["X-User-Id"] = request.state.user_id
    headers["X-Forwarded-For"] = request.client.host

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.request(
                method=request.method,
                url=target_url,
                headers=headers,
                content=await request.body(),
            )
        return JSONResponse(
            status_code=response.status_code,
            content=response.json(),
        )
    except httpx.ConnectError:
        return JSONResponse(
            status_code=503,
            content={
                "success": False,
                "error": {"code": "SERVICE_UNAVAILABLE", "detail": f"{service_name} servisine eriÅŸilemiyor"},
                "_links": {"health": {"href": "/health"}},
            },
        )
```

### 8.3 Service Registry

```python
# dispatcher/app/services/service_registry.py
from app.config import settings


class ServiceRegistry:
    """Servis adÄ±nÄ± iÃ§ aÄŸ URL'sine Ã§Ã¶zÃ¼mler."""

    def __init__(self):
        self._services: dict[str, str] = {
            "auth":     f"http://auth-service:{settings.AUTH_SERVICE_PORT}",
            "users":    f"http://user-service:{settings.USER_SERVICE_PORT}",
            "products": f"http://product-service:{settings.PRODUCT_SERVICE_PORT}",
        }

    def resolve(self, service_name: str, path: str) -> str | None:
        base_url = self._services.get(service_name)
        if not base_url:
            return None
        return f"{base_url}/{path}"

    def list_services(self) -> list[dict[str, str]]:
        return [
            {"name": name, "url": url}
            for name, url in self._services.items()
        ]
```

---

## 9. Docker Compose Tam YapÄ±landÄ±rma

```yaml
# docker-compose.yml
version: "3.9"

services:
  # â”€â”€ API Gateway â”€â”€
  dispatcher:
    build: ./dispatcher
    container_name: dispatcher
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379/0
      - AUTH_SERVICE_PORT=8001
      - USER_SERVICE_PORT=8002
      - PRODUCT_SERVICE_PORT=8003
    depends_on:
      redis:
        condition: service_healthy
      auth-service:
        condition: service_healthy
      user-service:
        condition: service_healthy
      product-service:
        condition: service_healthy
    networks:
      - public_network
      - gateway_network
      - internal_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 10s
      timeout: 5s
      retries: 3

  # â”€â”€ Redis (Auth Token Store) â”€â”€
  redis:
    image: redis:7-alpine
    container_name: redis
    command: redis-server --maxmemory 128mb --maxmemory-policy allkeys-lru
    networks:
      - gateway_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
    volumes:
      - redis_data:/data

  # â”€â”€ Auth Service â”€â”€
  auth-service:
    build: ./auth-service
    container_name: auth-service
    environment:
      - MONGO_URL=mongodb://mongo-auth:27017/auth_db
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      mongo-auth:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - internal_network
      - gateway_network   # Redis eriÅŸimi iÃ§in
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/health"]
      interval: 10s
      timeout: 5s
      retries: 3

  # â”€â”€ User Service â”€â”€
  user-service:
    build: ./user-service
    container_name: user-service
    environment:
      - MONGO_URL=mongodb://mongo-user:27017/user_db
    depends_on:
      mongo-user:
        condition: service_healthy
    networks:
      - internal_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8002/health"]
      interval: 10s
      timeout: 5s
      retries: 3

  # â”€â”€ Product Service â”€â”€
  product-service:
    build: ./product-service
    container_name: product-service
    environment:
      - MONGO_URL=mongodb://mongo-product:27017/product_db
    depends_on:
      mongo-product:
        condition: service_healthy
    networks:
      - internal_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8003/health"]
      interval: 10s
      timeout: 5s
      retries: 3

  # â”€â”€ MongoDB Instances â”€â”€
  mongo-auth:
    image: mongo:7
    container_name: mongo-auth
    networks:
      - internal_network
    volumes:
      - mongo_auth_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5

  mongo-user:
    image: mongo:7
    container_name: mongo-user
    networks:
      - internal_network
    volumes:
      - mongo_user_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5

  mongo-product:
    image: mongo:7
    container_name: mongo-product
    networks:
      - internal_network
    volumes:
      - mongo_product_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5

# â”€â”€ Volumes â”€â”€
volumes:
  redis_data:
  mongo_auth_data:
  mongo_user_data:
  mongo_product_data:

# â”€â”€ Networks â”€â”€
networks:
  public_network:
    driver: bridge
  gateway_network:
    driver: bridge
  internal_network:
    driver: bridge
    internal: true
```

### Monitoring Stack (AyrÄ± Compose DosyasÄ±)

```yaml
# docker-compose.monitoring.yml
version: "3.9"

services:
  prometheus:
    image: prom/prometheus:v2.51.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - public_network
      - internal_network
    command:
      - "--config.file=/etc/prometheus/prometheus.yml"
      - "--storage.tsdb.retention.time=7d"

  grafana:
    image: grafana/grafana:10.4.0
    container_name: grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_DASHBOARDS_DEFAULT_HOME_DASHBOARD_PATH=/var/lib/grafana/dashboards/dispatcher-dashboard.json
    volumes:
      - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards
      - grafana_data:/var/lib/grafana
    depends_on:
      - prometheus
    networks:
      - public_network

volumes:
  prometheus_data:
  grafana_data:
```

### Prometheus KonfigÃ¼rasyonu

```yaml
# monitoring/prometheus/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: "dispatcher"
    static_configs:
      - targets: ["dispatcher:8000"]
    metrics_path: /metrics

  - job_name: "auth-service"
    static_configs:
      - targets: ["auth-service:8001"]
    metrics_path: /metrics

  - job_name: "user-service"
    static_configs:
      - targets: ["user-service:8002"]
    metrics_path: /metrics

  - job_name: "product-service"
    static_configs:
      - targets: ["product-service:8003"]
    metrics_path: /metrics
```

---

## 10. YÃ¼k Testi AltyapÄ±sÄ±

### Locust Senaryosu

```python
# load-tests/locustfile.py
from locust import HttpUser, task, between, SequentialTaskSet


class AuthenticatedUser(SequentialTaskSet):
    """GerÃ§ekÃ§i kullanÄ±cÄ± senaryosu: login â†’ CRUD iÅŸlemleri."""

    token: str = ""

    def on_start(self):
        """Her kullanÄ±cÄ± oturumu login ile baÅŸlar."""
        resp = self.client.post("/api/v1/auth/login", json={
            "email": "loadtest@example.com",
            "password": "LoadTest123!",
        })
        if resp.status_code == 200:
            self.token = resp.json()["data"]["token"]

    @task(3)
    def get_profile(self):
        self.client.get(
            "/api/v1/users/me",
            headers={"Authorization": f"Bearer {self.token}"},
            name="/api/v1/users/me",
        )

    @task(2)
    def list_products(self):
        self.client.get(
            "/api/v1/products?page=1&per_page=10",
            headers={"Authorization": f"Bearer {self.token}"},
            name="/api/v1/products",
        )

    @task(1)
    def create_product(self):
        self.client.post(
            "/api/v1/products",
            json={"name": "Test ÃœrÃ¼n", "price": 99.99, "category": "Elektronik"},
            headers={"Authorization": f"Bearer {self.token}"},
            name="/api/v1/products [POST]",
        )


class WebsiteUser(HttpUser):
    tasks = [AuthenticatedUser]
    wait_time = between(1, 3)
    host = "http://localhost:8000"
```

### k6 Senaryosu

```javascript
// load-tests/k6/load_test.js
import http from "k6/http";
import { check, sleep } from "k6";
import { Rate, Trend } from "k6/metrics";

const errorRate = new Rate("errors");
const loginDuration = new Trend("login_duration");

export const options = {
  stages: [
    { duration: "30s", target: 10 },   // Ramp-up
    { duration: "1m",  target: 50 },   // Orta yÃ¼k
    { duration: "30s", target: 100 },  // YÃ¼ksek yÃ¼k
    { duration: "1m",  target: 100 },  // Sabit yÃ¼ksek yÃ¼k
    { duration: "30s", target: 0 },    // Ramp-down
  ],
  thresholds: {
    http_req_duration: ["p(95)<500"],   // %95'i 500ms altÄ±nda
    errors: ["rate<0.1"],               // Hata oranÄ± <%10
  },
};

const BASE_URL = "http://localhost:8000/api/v1";

export default function () {
  // Login
  const loginRes = http.post(`${BASE_URL}/auth/login`, JSON.stringify({
    email: "loadtest@example.com",
    password: "LoadTest123!",
  }), { headers: { "Content-Type": "application/json" } });

  loginDuration.add(loginRes.timings.duration);

  check(loginRes, {
    "login status 200": (r) => r.status === 200,
    "has token": (r) => r.json("data.token") !== undefined,
  }) || errorRate.add(1);

  const token = loginRes.json("data.token");
  const authHeaders = {
    Authorization: `Bearer ${token}`,
    "Content-Type": "application/json",
  };

  // Get profile
  const profileRes = http.get(`${BASE_URL}/users/me`, { headers: authHeaders });
  check(profileRes, {
    "profile status 200": (r) => r.status === 200,
    "has _links (HATEOAS)": (r) => r.json("_links") !== undefined,
  });

  sleep(1);

  // List products
  const productsRes = http.get(`${BASE_URL}/products?page=1`, { headers: authHeaders });
  check(productsRes, {
    "products status 200": (r) => r.status === 200,
    "has pagination _links": (r) => r.json("_links.self") !== undefined,
  });

  sleep(1);
}
```

---

## 11. Grafana Metrik Mimarisi

### Prometheus Metrikleri (Her Serviste)

```python
# shared/metrics.py
from prometheus_client import Counter, Histogram, Info
from prometheus_fastapi_instrumentator import Instrumentator

# Ã–zel metrikler
REQUEST_COUNT = Counter(
    "http_requests_total",
    "Toplam HTTP istek sayÄ±sÄ±",
    ["method", "endpoint", "status_code", "service"],
)

REQUEST_LATENCY = Histogram(
    "http_request_duration_seconds",
    "HTTP istek sÃ¼resi (saniye)",
    ["method", "endpoint", "service"],
    buckets=[0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0],
)

SERVICE_INFO = Info("service", "Servis bilgisi")


def setup_metrics(app, service_name: str):
    """FastAPI uygulamasÄ±na Prometheus metrikleri ekler."""
    SERVICE_INFO.info({"name": service_name, "version": "1.0.0"})
    Instrumentator(
        should_group_status_codes=False,
        excluded_handlers=["/health", "/metrics"],
    ).instrument(app).expose(app, endpoint="/metrics")
```

### Grafana Dashboard Panelleri

| Panel | Metrik | GÃ¶rselleÅŸtirme |
|---|---|---|
| Ä°stek/saniye | `rate(http_requests_total[5m])` | Time series |
| Gecikme (p95) | `histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))` | Time series |
| Hata oranÄ± | `rate(http_requests_total{status_code=~"5.."}[5m]) / rate(http_requests_total[5m])` | Gauge |
| Servis saÄŸlÄ±ÄŸÄ± | `up{job=~".*-service"}` | Stat panel |
| Aktif baÄŸlantÄ±lar | `http_requests_in_progress` | Gauge |

---

## 12. GeliÅŸtirme Yol HaritasÄ±

| Faz | SÃ¼re | Ã‡Ä±ktÄ± |
|---|---|---|
| **Faz 1**: AltyapÄ± | 1 hafta | Docker Compose, aÄŸ izolasyonu, CI/CD |
| **Faz 2**: Auth Service + Dispatcher | 1 hafta | Login/Register, Redis token, TDD |
| **Faz 3**: User Service | 1 hafta | CRUD + HATEOAS, baÄŸÄ±msÄ±z MongoDB |
| **Faz 4**: Product Service | 1 hafta | CRUD + HATEOAS, servisler arasÄ± link |
| **Faz 5**: Monitoring | 3 gÃ¼n | Prometheus + Grafana dashboard |
| **Faz 6**: YÃ¼k Testi & DokÃ¼mantasyon | 3 gÃ¼n | Locust/k6 + Rapor |

---

## Verification Plan

### Otomatik Testler

TÃ¼m servisler iÃ§in Ã§alÄ±ÅŸtÄ±rÄ±lacak komutlar:

```bash
# Her servisin kendi dizininde birim testleri Ã§alÄ±ÅŸtÄ±r
cd dispatcher && pytest tests/ -v --cov=app --cov-report=term-missing
cd auth-service && pytest tests/ -v --cov=app --cov-report=term-missing
cd user-service && pytest tests/ -v --cov=app --cov-report=term-missing
cd product-service && pytest tests/ -v --cov=app --cov-report=term-missing

# TÃ¼m sistemi Docker ile ayaÄŸa kaldÄ±r
docker-compose -f docker-compose.yml -f docker-compose.monitoring.yml up --build -d

# AÄŸ izolasyonunu doÄŸrula (dÄ±ÅŸarÄ±dan iÃ§ servislere eriÅŸilemediÄŸini kontrol et)
curl -f http://localhost:8001/health  # Bu BAÅARISIZ olmalÄ±
curl -f http://localhost:8000/health  # Bu BAÅARILI olmalÄ±

# YÃ¼k testi Ã§alÄ±ÅŸtÄ±r
cd load-tests && locust --headless -u 50 -r 10 --run-time 2m --host http://localhost:8000
```

### Manuel DoÄŸrulama

1. **Postman ile HATEOAS Testi**: Login â†’ `_links` iÃ§indeki URL'leri takip ederek tÃ¼m API'yi keÅŸfetme
2. **Grafana Dashboard**: `http://localhost:3000` Ã¼zerinden metriklerin gerÃ§ek zamanlÄ± izlenmesi
3. **Docker Network Testi**: `docker exec` ile iÃ§ aÄŸ konteynerlerinden dÄ±ÅŸ aÄŸa eriÅŸilemediÄŸinin doÄŸrulanmasÄ±
